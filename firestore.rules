/**
 * Core Philosophy: This ruleset enforces a strict multi-tenant security model where all data is partitioned by an organization ID (`orgId`). A user's access is strictly confined to the organization they belong to. No cross-organization data access is permitted.
 *
 * Data Structure: All application data is hierarchically organized under the top-level `orgs` collection. Each document within this structure (e.g., users, releases, outlet lists) contains a denormalized `orgId` field to enable efficient and secure authorization checks without costly lookups on parent documents.
 *
 * Key Security Decisions:
 * - Multi-Tenancy Firewall: The primary security boundary is the organization. All rules first verify that the authenticated user is a member of the organization associated with the data path.
 * - Role-Based Access: A three-tier role system ('Admin', 'User', 'Partner') is used. Admins have elevated privileges, Users manage content, and Partners can only submit content and view their own submissions.
 * - User Management: Only Admins can create or delete other users within their organization. Users can modify their own profile information.
 * - Org Provisioning: Creation and deletion of top-level organization documents are disallowed from the client, as these are assumed to be provisioned via a trusted server-side process.
 *
 * Denormalization for Authorization: To ensure performant and simple rules, every document contains an `orgId`. A user's role and organization membership are determined by a single `get` call to their own user document (`/orgs/{orgId}/users/{request.auth.uid}`). This avoids complex and slow multi-document reads during rule evaluation.
 *
 * Structural Segregation: Each data type (users, releases, etc.) is stored in its own dedicated subcollection under the parent organization. This clear separation ensures that security rules are specific and easy to manage for each data entity.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------------

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Retrieves the authenticated user's profile document from within a specific organization.
     * This is the primary function for fetching the user's role and orgId for authorization checks.
     */
    function getUserData(orgId) {
      return get(/databases/$(database)/documents/orgs/$(orgId)/users/$(request.auth.uid));
    }

    /**
     * Verifies if the authenticated user is a member of the specified organization.
     * This is the foundational rule for multi-tenancy.
     */
    function isOrgMember(orgId) {
      return isSignedIn() && exists(/databases/$(database)/documents/orgs/$(orgId)/users/$(request.auth.uid));
    }

    /**
     * Verifies if the authenticated user is an Admin of the specified organization.
     */
    function isOrgAdmin(orgId) {
      return isOrgMember(orgId) && getUserData(orgId).data.role == 'Admin';
    }

    /**
     * Verifies if the authenticated user is a team member (Admin or User, not Partner).
     */
    function isTeamMember(orgId) {
      return isOrgMember(orgId) && (getUserData(orgId).data.role == 'Admin' || getUserData(orgId).data.role == 'User');
    }

    /**
     * Checks if the authenticated user's UID matches the provided userId.
     * Used for rules that grant access to a user's own data.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * On create, validates that the incoming document's orgId matches the orgId in the path.
     * Enforces data consistency for new documents.
     */
    function hasCorrectOrgIdOnCreate(orgId) {
      return request.resource.data.orgId == orgId;
    }

    /**
     * On update, ensures the orgId of a document cannot be changed.
     * Prevents documents from being moved between organizations.
     */
    function isOrgIdImmutable() {
      return request.resource.data.orgId == resource.data.orgId;
    }


    /**
     * @description Rules for the top-level Organization documents.
     * @path /orgs/{orgId}
     * @allow (get) An authenticated member of the org reading their own organization's document.
     * @deny (create) Any user trying to create a new organization document from the client.
     * @principle Restricts modification of core organization data to Admins and disallows client-side creation/deletion.
     */
    match /orgs/{orgId} {
      allow get: if isOrgMember(orgId);
      allow list: if false;
      allow create: if false;
      allow update: if isOrgAdmin(orgId) && resource != null;
      allow delete: if false;
    }

    /**
     * @description Rules for User documents within an organization.
     * @path /orgs/{orgId}/users/{userId}
     * @allow (update) A user updating their own profile document.
     * @deny (delete) A non-admin user trying to delete another user's account in the same org.
     * @principle Enforces role-based access for user management; Admins manage all users, while individuals can manage their own profile.
     */
    match /orgs/{orgId}/users/{userId} {
      // Allow users to read their own document (needed for isOrgMember checks - breaks circular dependency)
      allow get: if isSignedIn() && request.auth.uid == userId;
      allow list: if isOrgMember(orgId);
      allow create: if isOrgAdmin(orgId) && hasCorrectOrgIdOnCreate(orgId) && request.resource.data.id == userId;
      allow update: if (isOrgAdmin(orgId) || isOwner(userId)) && resource != null && isOrgIdImmutable() && request.resource.data.id == resource.data.id;
      allow delete: if isOrgAdmin(orgId) && resource != null;
    }

    /**
     * @description Rules for Press Release documents within an organization.
     * @path /orgs/{orgId}/releases/{releaseId}
     * @principle Team members only (Admin/User). Partners cannot access releases.
     */
    match /orgs/{orgId}/releases/{releaseId} {
      allow read: if isTeamMember(orgId);
      allow create: if isTeamMember(orgId) && hasCorrectOrgIdOnCreate(orgId);
      allow update: if isTeamMember(orgId) && resource != null && isOrgIdImmutable();
      allow delete: if isTeamMember(orgId) && resource != null;
    }

    /**
     * @description Rules for Outlet List documents within an organization.
     * @path /orgs/{orgId}/outletLists/{outletListId}
     * @principle Team members only. Partners cannot access outlet lists.
     */
    match /orgs/{orgId}/outletLists/{outletListId} {
      allow read: if isTeamMember(orgId);
      allow create: if isTeamMember(orgId) && hasCorrectOrgIdOnCreate(orgId);
      allow update: if isTeamMember(orgId) && resource != null && isOrgIdImmutable();
      allow delete: if isTeamMember(orgId) && resource != null;
    }

    /**
     * @description Rules for Recipient documents within an Outlet List.
     * @path /orgs/{orgId}/outletLists/{outletListId}/recipients/{recipientId}
     * @principle Team members only. Partners cannot access recipients.
     */
    match /orgs/{orgId}/outletLists/{outletListId}/recipients/{recipientId} {
      allow read: if isTeamMember(orgId);
      allow create: if isTeamMember(orgId) && hasCorrectOrgIdOnCreate(orgId) && request.resource.data.outletListId == outletListId;
      allow update: if isTeamMember(orgId) && resource != null && isOrgIdImmutable() && request.resource.data.outletListId == resource.data.outletListId;
      allow delete: if isTeamMember(orgId) && resource != null;
    }

    /**
     * @description Rules for Send Job documents within an organization.
     * @path /orgs/{orgId}/sendJobs/{sendJobId}
     * @principle Team members only. Partners cannot access send jobs.
     */
    match /orgs/{orgId}/sendJobs/{sendJobId} {
      allow read: if isTeamMember(orgId);
      allow create: if isTeamMember(orgId) && hasCorrectOrgIdOnCreate(orgId);
      allow update: if isTeamMember(orgId) && resource != null && isOrgIdImmutable();
      allow delete: if isTeamMember(orgId) && resource != null;
    }

    /**
     * @description Rules for analytics Event documents within an organization.
     * @path /orgs/{orgId}/events/{eventId}
     * @principle Read-only for team members. Only Cloud Functions can write events.
     */
    match /orgs/{orgId}/events/{eventId} {
      allow read: if isTeamMember(orgId);
      allow create, update, delete: if false; // Only Cloud Functions can write events
    }

    /**
     * @description Rules for Partner Invite documents.
     * @path /orgs/{orgId}/invites/{inviteId}
     * @principle Only admins can manage invites.
     */
    match /orgs/{orgId}/invites/{inviteId} {
      allow read: if isOrgAdmin(orgId);
      allow create: if isOrgAdmin(orgId) && hasCorrectOrgIdOnCreate(orgId);
      allow update: if isOrgAdmin(orgId) && isOrgIdImmutable();
      allow delete: if isOrgAdmin(orgId);
    }

    /**
     * @description Rules for Tag documents.
     * @path /orgs/{orgId}/tags/{tagId}
     * @principle All org members (including partners) can read tags. Only admins can manage.
     */
    match /orgs/{orgId}/tags/{tagId} {
      allow read: if isOrgMember(orgId);
      allow create: if isOrgAdmin(orgId) && hasCorrectOrgIdOnCreate(orgId);
      allow update: if isOrgAdmin(orgId) && isOrgIdImmutable();
      allow delete: if isOrgAdmin(orgId);
    }

    /**
     * @description Rules for Media Request documents submitted by journalists.
     * @path /orgs/{orgId}/mediaRequests/{requestId}
     * @principle Public writes are handled exclusively by the submitStoryRequest Cloud Function.
     *            Team members can read and update status. No client-side create or delete.
     */
    match /orgs/{orgId}/mediaRequests/{requestId} {
      allow read: if isTeamMember(orgId);
      allow update: if isTeamMember(orgId) && resource != null && isOrgIdImmutable();
      allow create, delete: if false; // Cloud Function only
    }

    /**
     * @description Rules for Partner Submission documents.
     * @path /orgs/{orgId}/submissions/{submissionId}
     * @principle Team members can read all submissions. Partners can only read their own.
     *            Partners can create submissions (must set themselves as partnerId).
     *            Team members can update (status, notes). Only admins can delete.
     * @note For partner list queries, the query MUST include where('partnerId', '==', uid).
     */
    match /orgs/{orgId}/submissions/{submissionId} {
      // Team members read all; partners can only read their own (enforced by client query filter)
      allow get: if isTeamMember(orgId) || (isOrgMember(orgId) && resource.data.partnerId == request.auth.uid);
      allow list: if isOrgMember(orgId);
      allow create: if isOrgMember(orgId) &&
        hasCorrectOrgIdOnCreate(orgId) &&
        request.resource.data.partnerId == request.auth.uid;
      allow update: if isTeamMember(orgId) && resource != null && isOrgIdImmutable();
      allow delete: if isOrgAdmin(orgId) && resource != null;
    }
  }
}
